==注：此篇文章为单点测温ds18b20，并且只涉及部分元件命令==
[特征说明](#特征说明)
[结构介绍](#结构介绍)
	[64位ROM](#64位ROM)
	[EEPROM](#EEPROM)
	[暂存器RAM](#暂存器RAM)
[工作流程](#工作流程)
[单总线通信协议](#(单总线通信协议))
	[工作时序](#工作时序)
		[初始化时序](#初始化时序)
			[写时序](#写时序)
			[读时序](#读时序)
	[命令](#命令)
			[ROM命令](#ROM命令) 
			[RAM命令](#RAM命令)
[代码](#代码)
# 特征说明
1.  供电范围 3.3-5V
2. 测温范围 -55~+125℃
3. 分辨率9-12位
4. 常见封装 
![[1.png]]

# 结构介绍
![[3.png]]
## 64位ROM
作为期间地址，主要用于多点测温时的总线寻址
>本篇主要涉及单点测温，不在过多赘述

## EEPROM
EEPROM主要保存==温度触发阈值==和==配置参数==
每次上电暂存器RAM都会读EEPROM的参数用来初始化
分为三部分
- 上限触发TH(8位):当温度超过TH产生一个报警标识
- 下限触发TL (8位):当温度低于TL产生一个报警标识
  ![[Pasted image 20251224085731.png]]
- 配置寄存器:有用的只有两位R0，R1用来控制分辨率。其余位被保留禁止写入
  ![[Pasted image 20251224090037.png]]
## 暂存器RAM
暂存器为主要分为四部分
- 温度LSB：测量温度的低8位
- 温度MSB：测量温度的高8位
- 初始化部分：从EEPROM读取参数初始化
- 保留位
- CRC：验证码
  ![[Pasted image 20251224090830.png]]
我们最需要关注的是LSB，MSB这与我们读取温度密不可分
![[Pasted image 20251224090908.png]]
![[Pasted image 20251224090918.png]]
其中MSB前5位为符号位
MSB＋LSB整体上以补码来存低４位是小数位

# 工作流程
![[3.png]]
1. 上电RAM通过EEPROM初始化
2. 温度传感器将温度信号转为电信号存入RAM的LSB，MSB

# *单总线通信协议*
## 工作时序
### 初始化时序
![[Pasted image 20251224091751.png]]
主机拉低480-960us，再释放，等待15-60us，从机会拉低总线60-240us，则证明初始化成功。
初始化就相当于告诉ds28b20我要开始通信了
### 写时序
![[Pasted image 20251224092136.png]]
主机先拉低至少1us，若写1则拉高总线至少60us，若写0则拉低总线至少60us。从机将会在主机拉低1us后的15-60us内采样
### 读时序
![[Pasted image 20251224092634.png]]
主机先拉低至少1us，释放总线，然后在15us内采样。从机会在释放总线的15us内产生信号
## 命令
### ROM命令
### SKIP ROM [CCh] (忽略 ROM 指令) 
这条指令允许总线控制器不用提供64位ROM编码就使用功能指令。但只能在单点测温下使用

## RAM命令
### CONVERT T [44h] (温度转换指令)
这条命令用以启动一次温度转换。温度转换指令被执行，产生的温度转换结果数 据以2个字节的形式被存储在高速暂存器中
### READ SCRATCHPAD [BEh] （读暂存器指令） 
这条命令读取暂存器的内容。读取将从字节0开始，一只进行下去，直到将9个字节读完，如果不想读完所有字节，控制器可以在任何时间发出 复位命令来中止读取。

# 代码
**delay.c**
```C
#include "delay.h"

void DelayUs2x(unsigned char t)
{   
 while(--t);
}

void DelayMs(unsigned char t)
{   
 while(t--)
 {
     DelayUs2x(245);
	 DelayUs2x(245);
 }
}

```
**delay.h**
```C
#ifndef __DELAY_H__
#define __DELAY_H__
void DelayUs2x(unsigned char t);
void DelayMs(unsigned char t);
#endif

```
**ds18b20.c**
```C
#include "ds18b20.h"

//初始化
bit ds18b20Init()
{
	bit value;
	//主机拉低480-960us
	DQ=0;
	DelayUs2x(200);
	DelayUs2x(200);
	//释放等待15-60us
	DQ=1;
	DelayUs2x(50);
	//检测
	value=DQ;	
	DelayUs2x(25);
	return value;
}
//写字节
void ds18b20WriteByte(unsigned char s)
{
	char i;
	for(i=0;i<8;i++){
		DQ=0;
		DelayUs2x(1);
		DQ=s&0x01;
		DelayUs2x(25);
		DQ=1;
		DelayUs2x(5);
		s>>=1;
	}
}
//读字节
unsigned char ds18b20ReadByte()
{
	unsigned char value=0,i;
	for(i=0;i<8;i++){
		DQ=0;
		value>>=1;
		DQ=1;
		if(DQ) value|=0x80;
		DelayUs2x(25);
	}
	return value;
}

//读温度
float ds18b20Tem()
{
	float tem;
	unsigned char l=0;
	unsigned int h=0;
	unsigned int t=0;
	ds18b20Init();
	ds18b20WriteByte(0xCC);
	ds18b20WriteByte(0x44);
	DelayMs(250);
	DelayMs(250);
	
	ds18b20Init();
	ds18b20WriteByte(0xCC);
	ds18b20WriteByte(0xBE);
	l=ds18b20ReadByte();
	h=ds18b20ReadByte();
	
	h<<=8;
	t=h+l;
	if(t&0x8000>0) tem= (~t+1)*0.0625;
	else tem=t*0.0625;
	return tem;
}
```
**ds18b20.h**
```C
#ifndef _DS18B20_H_
#define _DS18B20_H_
#include <reg51.h>
#include <delay.h>

sbit DQ=P1^0;

bit ds18b20Init();
void ds18b20WriteByte(unsigned char s);
unsigned char ds18b20ReadByte();
float ds18b20Tem();
#endif
```
